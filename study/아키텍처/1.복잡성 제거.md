# 복잡성 제거

######_아키텍처는 복잡성 제거가 첫걸음_


좋은 아키텍처란?
-
풀려는 문제에 잘 어울리는 설계

1) 시스템이 어떻게 동작하는지를 잘 이해할 수 있도록 함
2) 요구사항이 진화함에도 쉽게 변경 가능해야함

__아래를 알기 쉬워야함__
- 이해하기
- 히스토리 알기 쉬움
- 유지하기
- 테스트하기 쉬움

나쁜냄새가 나지 않는다. 

아키텍처의 방해물 복잡성
-
아키텍처의 큰 방해물은 복잡성이다.   

_복잡성 != 코드 줄 수_  
(오히려 코드가 짧아도 복잡하는 경우도 있음..)

1. 복잡성 척도   
- 작은 변경 -> 많은곳 변경
- 작은 변경 -> 베이스 지식 파악필요
- 작은 변경 -> 예측 불과 결과

2. 복잡성 원인 3
- 의존성 (코드가 독립적으로 이해 및 수정 될수 없음)
- 불명확함 (중요한 정보가 불명확하고 중간과정, 결과를 모르겠음)
- 전술적 프로그래밍 (빨리 완성하기)

3. 복잡성 낮추는법
- 추상화 (깊은 모듈, 범용 인터페이스, 은닉)
- 깔끔한 추상화 (복잡성 아래로 내리기, 추상화 사이 경계 찾기)

추상화
-

1. 깊은 모듈

__모듈이란?__ 무언가를 구현하고 인터페이스를 제공하는 것(클래스,퍼블릭 메소드)   
__추상화란?__ 중요하지 않는 세부 사항을 감춰주는 간소화된 뷰

모듈의 깊이는 **작업량 그자체** 라고 부른다.

- 깊은 모듈   
  고도화된 작업량은 감추고 사용자가 알아야할 것만 인터페이스를 노출 시킴
  
  - 불필요한 정보로 혼란을 주지도 않고 사용자는 많은 것을 알 필요가 없어서  
    깊은 모듈은 좋은 예시  
    (길쭉한 모형이다. 맨위 얕은 면은 좁다.)
       

- 얖은 모듈은    
  불필요한 많은 메소드들이 퍼블릭으로 노출이 되어있다던가,   
   하나의 메소드로 완결이 안되서 여러 메소드를 불러야 한다던가, 
  - 인터페이스에 대한 정보를 통해서 기반으로 호출해야하는 문제점이 있음   
    인터페이스의 내부 작업 지식들을 조합해서 사용하게 되는 경우를 만들어버림

__좋은 모듈 예시: File io api__   
__나쁜 모듈 예시: 무의미 래퍼 클래스__ (깊은 모듈을 얕은 모듈로 바꿈)

범용 인터페이스
-
인터페이스는 크게 2가지 보편적인 목적과 특정 목적으로 나뉜다.  
범용은 지금 비용이 들고 특정용도는 나중에 비용이 든다.
```
// 범용 인터페이스
interface Printable {
    fun print()
}

// 특정 인터페이스
interface Drawable {
    fun draw()
}

class Circle : Printable, Drawable {
    override fun print() {
        println("Printing a circle")
    }

    override fun draw() {
        println("Drawing a circle")
    }
}

class Square : Printable {
    override fun print() {
        println("Printing a square")
    }
//  val shapes: List<Printable> = listOf(circle, square) 범용 인터페이스 사용, print()
    
```
__범용__   
세부사항 감추고 퍼블릭 api를 따로 만들어서 다른곳에서도 쓸 수 있도록   
설계 했다면 범용 인터페이스이다.

*좋은 인터페이스 판단 기준*   
- 현재의 요구사항을 모두 만족하는 것중에 무엇이 가장 심플한가?   
- 이 메소드가 얼마나 많은 상황에서 사용 되는가?   
- 이 Api는 나의 요구사항을 해결하는 데에 실제로 사용하기 편한가?


복잡성 아래로 끌어내리기
-
###### 복잡성 제거에 가장 중요한 부분중 하나

심플한 인터페이스는 심플한 구현보다 낫다.   
주의:무작정 내리고 올리면 남용시 오히려 정보 유출로 이어짐      
   
#### 중요 원칙: 아래의 경우에 끌어내리기
:: 기존에 있는 기능과 밀접하게 연관    
:: 앱의 여러 부분들을 더 단순하게 만들어주면   
:: 클래스의 인터페이스를 더 단순하게 만들어주면

```
//bad
bufferedReader.getBufSize()
bufferedReader.adjustBufSize()
bufferedReader.readNext()

//good
bufferedReader.readNext()

/*그리고.. getBufSize(), adjustBufSize() 를 private 으로 만들고 
readNext() 내부적으로 호출 */
```
#위 예제 의문점? 
?두개를 private 으로 바꾸면 재사용성을 낮추지 않나?   
-> 깊은 모듈 측면으로 바라볼 필요가 있음 

위 처럼 바꾸지 않을 시 생길 수 있는 현업 문제   
:: 액티비티에 많은 메소드들이 존재하고 재사용성을 위해 따로 빼내려고 해도 잘 분리가 안되는 일이 생김   
:: 그래서 깊은 모듈을 만들 때는 재사용성과 상관 없이 의미 단위로 가독성 단위로
잘 나눌 필요가 있음
 
추상화 사이 경계 찾기
-
  ###합쳐야 하는경우
1) 정보가 공유 될 때
2) 함께 해야 인터페이스가 단순해질 때
3) 코드 중복을 제거할 수 있을때
   적신호) 코드 반복은 추상화가 잘 이뤄지지 않았음을 의미함

###나눠야 하는 경우
1) 특정 목적의 Api가 범용 클래스 안에 있을 때
2) 다른 종류의 범용 메카니즘이 함께 있을때

### 재사용성
- 인터페이스의 복잡성 측면에서 검토되어야 함
  - 사용성을 더 낮게 하는 측면에서 검토해야 함   

*공통되는 코드를 통해서 새로운 퍼블릭한 인터페이스가 도출되지 않으면
미루는게 나을 수 있음*